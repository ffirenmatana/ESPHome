time:
  - platform: homeassistant
    id: homeassistant_time

i2c:
  sda: GPIO41
  scl: GPIO42
  scan: true
  frequency: 400kHz

# ADS1115 configuration
ads1115:
  - address: 0x48 
    id: ads1115_hub

# Persistent storage for calibration parameters - MUST be defined before sensors
number: 
  - platform: template
    name: "EC Calibration Slope"
    id: ec_slope
    entity_category: config
    min_value: 0.1
    max_value: 100.0
    initial_value: 21.227
    step: 0.001
    optimistic: true
    restore_value: true

  - platform: template
    name: "EC Calibration Offset"
    id: ec_offset
    entity_category: config
    min_value: -1000.0
    max_value: 1000.0
    initial_value: 0.0
    step: 0.1
    optimistic: true
    restore_value: true
  
  - platform: template
    name: "Reference Temperature"
    id: ref_temp
    entity_category: config 
    min_value: 20
    max_value: 30
    initial_value: 23.92
    step: 0.01
    optimistic: true
    restore_value: true

  - platform: template
    name: "Last Calibration Timestamp"
    id: last_calibration_timestamp
    entity_category: config
    min_value: 0
    max_value: 2147483647
    initial_value: 1758376812
    step: 1
    optimistic: true
    restore_value: true  
    internal: true  
  
  - platform: template
    name: "Temperature Calibration Offset"
    id: temp_offset
    entity_category: config
    min_value: -20.0
    max_value: 20.0
    initial_value: 0 
    step: 0.01
    optimistic: true
    restore_value: true

  - platform: template
    name: "Temperature Calibration Slope"
    id: temp_slope
    entity_category: config 
    min_value: 0.5
    max_value: 1.5
    initial_value: 0.7474
    step: 0.0001
    optimistic: true
    restore_value: true
    
sensor:
    # EC probe's integrated PT1000 temperature sensor via ADS1115
  - platform: ads1115
    ads1115_id: ads1115_hub
    multiplexer: 'A1_GND'  
    gain: 1.024
    name: "Temperature Voltage"
    id: pt1000_voltage
    update_interval: 2s  
    # accuracy_decimals: 8
    internal: false
    filters:
      - median:
          window_size: 5
          send_every: 1

  # Convert PT1000 voltage to temperature using DFRobot's conversion formula
  - platform: template
    id: pt1000_temperature
    name: "Water Temperature"
    unit_of_measurement: "°C"
    accuracy_decimals: 2
    internal: false
    update_interval: 2s
    filters:
      - median:
          window_size: 5
          send_every: 1
    lambda: |-
      float voltage = id(pt1000_voltage).state;
      if (isnan(voltage)) return {};

      // PT1000 temperature calculation based on DFRobot code
      float rpt1000 = (voltage / 16.67 + 0.223) / 0.000124 / 2.0;  
      float temp_raw = (rpt1000 - 1000.0) / 3.85;
      float temp = (temp_raw * id(temp_slope).state) + id(temp_offset).state;
      return temp;

  # Voltage reading from EC sensor via ADS1115
  - platform: ads1115
    ads1115_id: ads1115_hub
    multiplexer: 'A0_GND'  
    gain: 4.096
    name: "EC Voltage"
    id: ec_voltage
    update_interval: 2s
    accuracy_decimals: 4
    internal: false
    
  # EC Value using internal temperature
  - platform: template
    name: "EC Internal"
    id: ec_internal
    unit_of_measurement: "µS/cm"
    device_class: "conductivity"
    state_class: "measurement"
    update_interval: 2s
    lambda: |-
      float voltage = id(ec_voltage).state * 1000; 
      float temperature = id(pt1000_temperature).state;
      if (isnan(voltage) || isnan(temperature)) return {};
      
      float ec_raw = 100000.0 * voltage / 820.0 / 200.0 * id(ec_slope).state; 
      float ec_compensated = ec_raw / (1.0 + 0.02 * (temperature - 25.0));
      ec_compensated += id(ec_offset).state;
      
      return ec_compensated;

  - platform: template
    id: salinity
    name: "Salinity"
    unit_of_measurement: "ppt"
    accuracy_decimals: 2
    update_interval: 2s
    lambda: |-
      float voltage = id(ec_voltage).state * 1000;
      float temperature = id(pt1000_temperature).state;
      float kvalue = id(ec_slope).state; 
      
      if (isnan(voltage) || isnan(temperature)) return {};
      
      // EC calculation with temperature compensation
      float ec_raw = 100000.0 * voltage / 820.0 / 200.0 * id(ec_slope).state;
      float ec_compensated = ec_raw / (1.0 + 0.02 * (temperature - 25.0));
      ec_compensated += id(ec_offset).state;
      
      return ec_compensated * 0.00066;


  - platform: template
    name: "Days Since Last Calibration"
    id: days_since_calibration
    unit_of_measurement: "days"
    device_class: "duration"
    state_class: "measurement"
    entity_category: diagnostic
    accuracy_decimals: 1
    update_interval: 1h
    lambda: |-
      uint32_t last_cal_timestamp = (uint32_t)id(last_calibration_timestamp).state;
      
      // If never calibrated, return a large number to indicate this
      if (last_cal_timestamp == 0) {
        return 999.9;  // Indicates "never calibrated"
      }
      
      // Get current time from Home Assistant
      auto time = id(homeassistant_time).now();
      if (!time.is_valid()) {
        ESP_LOGW("calibration", "Time not available from Home Assistant");
        return {};  // Return empty optional if time not available
      }
      
      uint32_t current_timestamp = time.timestamp;
      
      // Calculate time difference in seconds
      uint32_t time_diff = current_timestamp - last_cal_timestamp;
      
      // Convert to days (86400 seconds per day)
      float days = time_diff / 86400.0;
      
      return days;

button:
  - platform: template
    name: "Calibrate EC to 53000 µS/cm"
    id: calibrate_ec_button
    entity_category: diagnostic
    on_press:
      - lambda: |-
          float current_voltage = id(ec_voltage).state * 1000;
          float current_temp = id(ref_temp).state;
          
          if (isnan(current_temp)) {
            current_temp = 24.5;
          }
          
          const float target_ec = 53000.0;
          
          if (current_voltage > 0) {
            float current_offset = id(ec_offset).state;
            float temp_coeff = 1.0 + 0.02 * (current_temp - 25.0);
            
            // EC formula: ec = (100000 * voltage / 820 / 200 * slope / temp_coeff) + offset
            // Solving for slope: slope = (target_ec - offset) * temp_coeff / (100000 * voltage / 820 / 200)
            float voltage_factor = 100000.0 * current_voltage / 820.0 / 200.0;
            float new_slope = ((target_ec - current_offset) * temp_coeff) / voltage_factor;
            
            if (new_slope > 0.1 && new_slope < 100.0) {
              auto call = id(ec_slope).make_call();
              call.set_value(new_slope);
              call.perform();
              
              // Record calibration timestamp
              auto time = id(homeassistant_time).now();
              if (time.is_valid()) {
                auto timestamp_call = id(last_calibration_timestamp).make_call();
                timestamp_call.set_value((float)time.timestamp);
                timestamp_call.perform();
                
                ESP_LOGI("calibration", "Calibration timestamp saved: %u", time.timestamp);
              } else {
                ESP_LOGW("calibration", "Could not get current time for calibration timestamp");
              }
              
              id(days_since_calibration).update();
              
              ESP_LOGI("calibration", "EC Calibration completed!");
              ESP_LOGI("calibration", "Raw Voltage: %.2f mV, Temperature: %.2f°C", current_voltage, current_temp);
              ESP_LOGI("calibration", "New cal_slope: %.3f (old: %.3f)", new_slope, id(ec_slope).state);
              ESP_LOGI("calibration", "Voltage factor: %.2f", voltage_factor);
              ESP_LOGI("calibration", "Target EC: %.0f µS/cm", target_ec);
            } else {
              ESP_LOGE("calibration", "Calculated slope out of bounds: %.3f", new_slope);
              ESP_LOGE("calibration", "Raw voltage: %.2f mV, check sensor readings", current_voltage);
            }
          } else {
            ESP_LOGE("calibration", "Invalid raw voltage reading: %.2f mV", current_voltage);
          }
          
  - platform: restart
    name: "Salinity Controller Restart"
    icon: "mdi:restart"
    entity_category: diagnostic


