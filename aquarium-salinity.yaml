esphome:
  name: salinity
  friendly_name: "Aquarium: Salinity"

esp32:
  board: esp32-s3-devkitc-1
  framework:
    type: esp-idf

# Enable logging
logger:

# Enable Home Assistant API
api:
  encryption:
    key: 

ota:
  - platform: esphome
    password: 

wifi:
  ssid: !secret wifi_ssid_fish
  password: !secret wifi_password_fish
  domain: 
  fast_connect: true
  manual_ip:
    static_ip: 10.10.10.41
    gateway: 10.10.10.1
    subnet: 255.255.255.0

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Aquarium-Salinity"
    password: 
captive_portal:

web_server:
  port: 80
  local: true
  version: 3
  auth:
    username: !secret web_user
    password: !secret web_pw

time:
  - platform: homeassistant
    id: homeassistant_time

# I2C configuration for ADS1115
i2c:
  sda: GPIO8   #
  scl: GPIO9   
  scan: true
  frequency: 400kHz

# ADS1115 configuration
ads1115:
  - address: 0x48  
    id: ads1115_hub

globals:
  - id: res2
    type: float
    initial_value: '820.0'
  - id: ecref
    type: float
    initial_value: '200.0'
  - id: gdiff
    type: float
    initial_value: '16.67'  
  - id: vr0
    type: float
    initial_value: '0.223'
  - id: g0
    type: float
    initial_value: '2.0'
  - id: current_i
    type: float
    initial_value: '0.000124'      

# Persistent storage for calibration parameters - MUST be defined before sensors
number:
  - platform: template
    name: "EC Calibration Slope"
    id: cal_slope
    entity_category: config
    min_value: 0.1
    max_value: 100.0
    initial_value: 12.932
    step: 0.001
    optimistic: true
    restore_value: true

  - platform: template
    name: "EC Calibration Offset"
    id: cal_offset
    entity_category: config
    min_value: -1000.0
    max_value: 1000.0
    initial_value: 0.0
    step: 0.1
    optimistic: true
    restore_value: true

  - platform: template
    name: "Temperature Calibration Offset"
    id: temp_cal_offset
    entity_category: config
    min_value: -20.0
    max_value: 20.0
    initial_value: 0 
    step: 0.01
    optimistic: true
    restore_value: true

  - platform: template
    name: "Temperature Calibration Slope"
    id: temp_cal_slope
    entity_category: config 
    min_value: 0.5
    max_value: 1.5
    initial_value: 0.9823
    step: 0.0001
    optimistic: true
    restore_value: true
  
  - platform: template
    name: "Reference Temperature"
    id: temp_reference
    entity_category: config 
    min_value: 20
    max_value: 30
    initial_value: 23.8
    step: 0.01
    optimistic: true
    restore_value: true

  - platform: template
    name: "Last Calibration Timestamp"
    id: last_calibration_timestamp
    entity_category: config
    min_value: 0
    max_value: 2147483647  # Max uint32_t value
    initial_value: 1
    step: 1
    optimistic: true
    restore_value: true  
    internal: true  

sensor:
  # EC probe's integrated PT1000 temperature sensor via ADS1115
  - platform: ads1115
    ads1115_id: ads1115_hub
    multiplexer: 'A1_GND'  # PT1000 temperature sensor on A1
    gain: 4.096  # ±4.096V range (good for PT1000 circuit)
    name: "Temperature Voltage"
    id: pt1000_voltage
    update_interval: 5s
    accuracy_decimals: 8
    internal: false  # Hide raw voltage reading
    filters:
      - median:
          window_size: 3
    
  # Convert PT1000 voltage to temperature using DFRobot's conversion formula
  - platform: template
    id: pt1000_temperature
    name: "Water Temperature"
    unit_of_measurement: "°C"
    accuracy_decimals: 2
    update_interval: 5s
    filters:
      - median:
          window_size: 3
    lambda: |-
      float voltage = id(pt1000_voltage).state;
      if (isnan(voltage)) return {};

      // PT1000 temperature calculation based on DFRobot code
      float rpt1000 = (voltage / id(gdiff) + id(vr0)) / id(current_i) / id(g0);
      float temp_raw = (rpt1000 - 1000.0) / 3.85;
      float temp = (temp_raw * id(temp_cal_slope).state) + id(temp_cal_offset).state;
      return temp;

  # Voltage reading from EC sensor via ADS1115
  - platform: ads1115
    ads1115_id: ads1115_hub
    multiplexer: 'A0_GND'  # Single-ended input on A0
    gain: 6.144  # ±6.144V range (adjust based on your sensor's output range)
    name: "EC Voltage"
    id: ec_voltage
    update_interval: 5s
    accuracy_decimals: 4
    internal: false  # Hide from HA if you only want the final EC value
    
  # EC Value calculated sensor
  - platform: template
    name: "EC Value"
    id: ec_compensated
    unit_of_measurement: "µS/cm"
    device_class: "conductivity"
    state_class: "measurement"
    update_interval: 5s
    accuracy_decimals: 0
    lambda: |-
      float voltage = id(ec_voltage).state * 1000;
      float temperature = id(pt1000_temperature).state;
      float kvalue = id(cal_slope).state; 
      
      if (isnan(voltage) || isnan(temperature)) return {};
      
      // EC calculation with temperature compensation
      float ec_raw = 100000.0 * voltage / id(res2) / id(ecref) * kvalue;
      float ec_compensated = ec_raw / (1.0 + 0.02 * (temperature - 25.0));
      ec_compensated += id(cal_offset).state;
      
      return ec_compensated;

  - platform: template
    id: salinity
    name: "Salinity"
    unit_of_measurement: "ppt"
    accuracy_decimals: 2
    update_interval: 5s
    lambda: |-
      float voltage = id(ec_voltage).state * 1000;
      float temperature = id(pt1000_temperature).state;
      float kvalue = id(cal_slope).state; 
      
      if (isnan(voltage) || isnan(temperature)) return {};
      
      // EC calculation with temperature compensation
      float ec_raw = 100000.0 * voltage / id(res2) / id(ecref) * kvalue;
      float ec_compensated = ec_raw / (1.0 + 0.02 * (temperature - 25.0));
      ec_compensated += id(cal_offset).state;
      
      return ec_compensated * 0.00066;

  - platform: template
    name: "Days Since Last Calibration"
    id: days_since_calibration
    unit_of_measurement: "days"
    device_class: "duration"
    state_class: "measurement"
    entity_category: diagnostic
    accuracy_decimals: 1
    update_interval: 1h  # Update every hour
    lambda: |-
      uint32_t last_cal_timestamp = (uint32_t)id(last_calibration_timestamp).state;
      
      // If never calibrated, return a large number to indicate this
      if (last_cal_timestamp == 0) {
        return 999.9;  // Indicates "never calibrated"
      }
      
      // Get current time from Home Assistant
      auto time = id(homeassistant_time).now();
      if (!time.is_valid()) {
        ESP_LOGW("calibration", "Time not available from Home Assistant");
        return {};  // Return empty optional if time not available
      }
      
      uint32_t current_timestamp = time.timestamp;
      
      // Calculate time difference in seconds
      uint32_t time_diff = current_timestamp - last_cal_timestamp;
      
      // Convert to days (86400 seconds per day)
      float days = time_diff / 86400.0;
      
      return days;

button:
  - platform: template
    name: "Calibrate Temperature Sensor"
    id: calibrate_temp_button
    entity_category: diagnostic
    on_press:
      - lambda: |-
          // Get the raw temperature reading (no calibration applied)
          float raw_temp = id(pt1000_temperature).state;
          
          // Get the reference temperature from the GUI input
          float reference_temp = id(temp_reference).state;
          
          if (!isnan(raw_temp) && !isnan(reference_temp) && raw_temp > 0) {
            // Calculate new slope: slope = reference_temp / raw_temp
            float new_slope = reference_temp / raw_temp;
            
            // Reasonable bounds check
            if (new_slope > 0.80 && new_slope < 1.20) {
              auto call = id(temp_cal_slope).make_call();
              call.set_value(new_slope);
              call.perform();
              
              ESP_LOGI("temp_calibration", "Temperature Calibration completed!");
              ESP_LOGI("temp_calibration", "Raw Temperature: %.3f°C", raw_temp);
              ESP_LOGI("temp_calibration", "Reference Temperature: %.1f°C", reference_temp);
              ESP_LOGI("temp_calibration", "New temp_cal_slope: %.4f", new_slope);
              ESP_LOGI("temp_calibration", "Calibrated Temperature will be: %.2f°C", raw_temp * new_slope);
            } else {
              ESP_LOGE("temp_calibration", "Calculated slope out of bounds: %.4f", new_slope);
              ESP_LOGE("temp_calibration", "Raw temp: %.3f, Reference: %.1f", raw_temp, reference_temp);
              ESP_LOGE("temp_calibration", "Try adjusting the reference temperature or check sensor readings");
            }
          } else {
            ESP_LOGE("temp_calibration", "Invalid readings - Raw temp: %.3f, Reference: %.1f", raw_temp, reference_temp);
          }

  - platform: template
    name: "Calibrate EC to 53000 µS/cm"
    id: calibrate_ec_button
    entity_category: diagnostic
    on_press:
      - lambda: |-
          // Use RAW voltage reading for calibration (not smoothed)
          float current_voltage = id(ec_voltage).state;
          float current_temp = id(pt1000_temperature).state;
          float kvalue = id(cal_slope).state; 

          
          if (isnan(current_temp)) {
            current_temp = 24.5;
          }
          
          const float target_ec = 53000.0;
          
          if (current_voltage > 0) {
            float current_slope = kvalue;
            float current_offset = id(cal_offset).state;
            float temp_coeff = 1.0 + 0.02 * (current_temp - 25.0);
            float new_slope = ((target_ec - current_offset) * temp_coeff) / current_voltage;
            
            if (new_slope > 0.1 && new_slope < 100.0) {
              auto call = id(cal_slope).make_call();
              call.set_value(new_slope);
              call.perform();
              
              // Record calibration timestamp using Home Assistant time
              auto time = id(homeassistant_time).now();
              if (time.is_valid()) {
                auto timestamp_call = id(last_calibration_timestamp).make_call();
                timestamp_call.set_value((float)time.timestamp);
                timestamp_call.perform();
                
                ESP_LOGI("calibration", "Calibration timestamp saved: %u", time.timestamp);
              } else {
                ESP_LOGW("calibration", "Could not get current time for calibration timestamp");
              }
              
              // Force immediate update of the days sensor
              id(days_since_calibration).update();
              
              ESP_LOGI("calibration", "EC Calibration completed!");
              ESP_LOGI("calibration", "Raw Voltage: %.2f mV, Temperature: %.2f°C", current_voltage, current_temp);
              ESP_LOGI("calibration", "New cal_slope: %.3f", new_slope);
              ESP_LOGI("calibration", "Target EC: %.0f µS/cm", target_ec);
            } else {
              ESP_LOGE("calibration", "Calculated slope out of bounds: %.3f", new_slope);
              ESP_LOGE("calibration", "Raw voltage: %.2f mV, check sensor readings", current_voltage);
            }
          } else {
            ESP_LOGE("calibration", "Invalid raw voltage reading: %.2f mV", current_voltage);
          }

  - platform: restart
    name: "Salinity Controller Restart"
    icon: "mdi:restart"
    entity_category: diagnostic
