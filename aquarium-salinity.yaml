esphome:
  name: salinity
  friendly_name: "Aquarium: Salinity"

esp32:
  board: esp32-s3-devkitc-1
  framework:
    type: esp-idf

logger:

api:
  encryption:
    key: !secret_api_key

ota:
  - platform: esphome
    password: !secret_ota_password

wifi:
  ssid: !secret wifi_ssid_fish
  password: !secret wifi_password_fish
  domain: !secret_domain
  fast_connect: true
  manual_ip:
    static_ip: 10.10.10.41
    gateway: 10.10.10.1
    subnet: 255.255.255.0
  ap:
    
captive_portal:

web_server:
  port: 80
  local: true
  version: 3
  auth:
    username: !secret web_user
    password: !secret web_pw

esphome:
  name: salinity
  friendly_name: "Aquarium: Salinity"

esp32:
  board: esp32-s3-devkitc-1
  framework:
    type: esp-idf

# Enable logging
logger:

# Enable Home Assistant API
api:
  encryption:
    key: "9Nm/RvrwxZljqYW/tQIIawYTX75BHaxjMP54pjA2z4w="

ota:
  - platform: esphome
    password: "3f71170f6ef4c8d593133ee85a2afcd9"

wifi:
  ssid: !secret wifi_ssid_fish
  password: !secret wifi_password_fish
  domain: .bushe.com.au
  fast_connect: true
  manual_ip:
    static_ip: 10.10.10.41
    gateway: 10.10.10.1
    subnet: 255.255.255.0
  ap:
    
captive_portal:

web_server:
  port: 80
  local: true
  version: 3
  auth:
    username: !secret web_user
    password: !secret web_pw

time:
  - platform: homeassistant
    id: homeassistant_time

i2c:
  sda: GPIO41
  scl: GPIO42
  scan: true
  frequency: 400kHz

# ADS1115 configuration
ads1115:
  - address: 0x48 
    id: ads1115_hub

# Persistent storage for calibration parameters - MUST be defined before sensors
number: 
  - platform: template
    name: "EC Calibration Slope"
    id: ec_slope
    entity_category: config
    min_value: 0
    max_value: 30
    initial_value: 24.5772
    step: 0.0001
    optimistic: true
    restore_value: true

  - platform: template
    name: "EC Calibration Offset"
    id: ec_offset
    entity_category: config
    min_value: -30.0
    max_value: 30.0
    initial_value: 0.0
    step: 0.1
    optimistic: true
    restore_value: true

  - platform: template
    name: "Last Calibration Timestamp"
    id: last_calibration_timestamp
    entity_category: config
    min_value: 0
    max_value: 2147483647
    initial_value: 1758376812
    step: 1
    optimistic: true
    restore_value: true  
    internal: true  
  
  - platform: template
    name: "Temperature Calibration Offset"
    id: temp_offset
    entity_category: config
    min_value: -20.0
    max_value: 20.0
    initial_value: 4.6
    step: 0.01
    optimistic: true
    restore_value: true

  - platform: template
    name: "Temperature Calibration Slope"
    id: temp_slope
    entity_category: config 
    min_value: -10
    max_value: 10
    initial_value: -7.65
    step: 0.0001
    optimistic: true
    restore_value: true
    
sensor:
  - platform: ads1115
    ads1115_id: ads1115_hub
    multiplexer: 'A0_GND'  
    gain: 1.024
    name: "Temperature Voltage"
    id: pt1000_voltage
    update_interval: 2s  
    accuracy_decimals: 4
    internal: true
    filters:
      - median:
          window_size: 3 
          send_every: 1

  - platform: template
    id: pt1000_temperature
    name: "Water Temperature"
    unit_of_measurement: "°C"
    accuracy_decimals: 2
    update_interval: 5s
    filters:
      - sliding_window_moving_average:
          window_size: 5
          send_every: 1
      - lambda: |-
          return round(x * 100.0) / 100.0;
    lambda: |-
      float voltage = id(pt1000_voltage).state;
      if (isnan(voltage)) return {};
      float rpt1000 = (voltage / 16.67 + 0.223) / 0.000124 / 2.0; 
      float temp_raw = (rpt1000 - 1000.0) / 3.85;
      float temp = (temp_raw * id(temp_slope).state) + id(temp_offset).state;
      return temp;
    
  - platform: ads1115
    ads1115_id: ads1115_hub
    multiplexer: 'A1_GND'  
    gain: 4.096
    name: "EC Voltage"
    id: ec_voltage
    update_interval: 2s
    unit_of_measurement: V
    accuracy_decimals: 4
    internal: true
    filters:
    - median:
        window_size: 3
        send_every: 1

  - platform: template
    name: "Electrical Conductivity"
    id: ec
    unit_of_measurement: "µS/cm"
    device_class: "conductivity"
    state_class: "measurement"
    update_interval: 5s
    filters:
      - sliding_window_moving_average:
          window_size: 15
          send_every: 1
    lambda: |-
      float measured = id(ec_voltage).state;         // V_adc (after divider)
      float voltage = (measured / 0.6) * 1000.0;     // true probe voltage in mV
      float temperature = id(pt1000_temperature).state;
      if (isnan(voltage) || isnan(temperature)) return {};

      // Raw EC from probe voltage (before temperature compensation)
      float ec_raw = 100000.0 * voltage / 820.0 / 200.0 * id(ec_slope).state;

      // Improved temperature compensation for seawater in at my expected temp range
      const float alpha = 0.019f;        // 1.9% per °C
      const float tref  = 27.0f;         // more realistic reference for your tank
      float temp_coeff  = 1.0f + alpha * (temperature - tref);

      float ec_compensated = ec_raw / temp_coeff;
      ec_compensated += id(ec_offset).state;
      return ec_compensated;

  - platform: template
    id: salinity
    name: "Salinity"
    unit_of_measurement: "ppt"
    accuracy_decimals: 2
    update_interval: 10s
    filters:
      - sliding_window_moving_average:
          window_size: 9
          send_every: 1
    lambda: |-
      float ec25 = id(ec).state;
      if (isnan(ec25)) return {};
      return ec25 * 0.00066;

  - platform: template
    name: "Days Since Last Calibration"
    id: days_since_calibration
    unit_of_measurement: "days"
    device_class: "duration"
    state_class: "measurement"
    entity_category: diagnostic
    accuracy_decimals: 1
    update_interval: 1h
    lambda: |-
      uint32_t last_cal_timestamp = (uint32_t)id(last_calibration_timestamp).state;
      
      // If never calibrated, return a large number to indicate this
      if (last_cal_timestamp == 0) {
        return 999.9;  // Indicates "never calibrated"
      }
      
      // Get current time from Home Assistant
      auto time = id(homeassistant_time).now();
      if (!time.is_valid()) {
        ESP_LOGW("calibration", "Time not available from Home Assistant");
        return {};  // Return empty optional if time not available
      }
      
      uint32_t current_timestamp = time.timestamp;
      
      // Calculate time difference in seconds
      uint32_t time_diff = current_timestamp - last_cal_timestamp;
      
      // Convert to days (86400 seconds per day)
      float days = time_diff / 86400.0;
      
      return days;

button:
  - platform: template
    name: "Calibrate EC to 53000 µS/cm"
    id: calibrate_ec_button
    entity_category: diagnostic
    on_press:
      - lambda: |-
          // Read divided ADC voltage
          float measured = id(ec_voltage).state;             // V_adc
          // Undo divider and convert to mV (true probe voltage)
          float current_voltage = (measured / 0.6) * 1000.0; // V_probe in mV

          float current_temp = id(pt1000_temperature).state;
          
          if (isnan(current_temp)) {
            current_temp = 24.5;
          }
          
          const float target_ec = 53000.0;
          
          if (current_voltage > 0) {
            float current_offset = id(ec_offset).state;
            const float alpha = 0.019f;
            const float tref  = 27.0f;
            float temp_coeff  = 1.0f + alpha * (current_temp - tref);
            
            // EC formula: ec = (100000 * voltage / 820 / 200 * slope / temp_coeff) + offset
            // Solving for slope: slope = (target_ec - offset) * temp_coeff / (100000 * voltage / 820 / 200)
            float voltage_factor = 100000.0 * current_voltage / 820.0 / 200.0;
            float new_slope = ((target_ec - current_offset) * temp_coeff) / voltage_factor;
            
              if (new_slope > 0.1 && new_slope < 100.0) {
              auto call = id(ec_slope).make_call();
              call.set_value(new_slope);
              call.perform();
              
              // Record calibration timestamp
              auto time = id(homeassistant_time).now();
              if (time.is_valid()) {
                auto timestamp_call = id(last_calibration_timestamp).make_call();
                timestamp_call.set_value((float)time.timestamp);
                timestamp_call.perform();
                
                ESP_LOGI("calibration", "Calibration timestamp saved: %u", time.timestamp);
              } else {
                ESP_LOGW("calibration", "Could not get current time for calibration timestamp");
              }
              
              id(days_since_calibration).update();
              
              ESP_LOGI("calibration", "EC Calibration completed!");
              ESP_LOGI("calibration", "Raw Voltage: %.2f mV, Temperature: %.2f°C", current_voltage, current_temp);
              ESP_LOGI("calibration", "New cal_slope: %.3f (old: %.3f)", new_slope, id(ec_slope).state);
              ESP_LOGI("calibration", "Voltage factor: %.2f", voltage_factor);
              ESP_LOGI("calibration", "Target EC: %.0f µS/cm", target_ec);
            } else {
              ESP_LOGE("calibration", "Calculated slope out of bounds: %.3f", new_slope);
              ESP_LOGE("calibration", "Raw voltage: %.2f mV, check sensor readings", current_voltage);
            }
          } else {
            ESP_LOGE("calibration", "Invalid raw voltage reading: %.2f mV", current_voltage);
          }
          
  - platform: restart
    name: "Salinity Controller Restart"
    icon: "mdi:restart"
    entity_category: diagnostic


